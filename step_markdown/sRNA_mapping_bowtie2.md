# sRNA-seq alignment

Here we use *Arabidopsis thaliana* genome as an example to prepare potential tRFs screening protocol.

- [Aligning reads to plant genomes](#aligning-reads-to-plant-genomes)

  - [Indexing](#indexing)

  - [Aligning](#aligning)

  - [Convert sam to bam file for minimum storage stress](#convert-sam-to-bam-file-for-minimum-storage-stress)

  - [Reads ratio from plant](#reads-ratio-from-plant)

- [Aligning different reads to bacterial genomes](#aligning-different-reads-to-bacterial-genomes)

  - [Extract sequences of only 1 mismatch](#extract-sequences-of-only-1-mismatch)

**Using Bowtie2 for reads alignment**: Because of the problem of downloading Bowtie. I decided to adopt Bowtie2, though Bowtie has advantages in mapping short reads.

It was relatively fast and convenient in using Bowtie2. Bowtie2 used reads seed region. The only 1 mismatch allowed within seed regions in genome alignment cannot be ignored though, especially analyzing sRNA.

First, I aligned sRNA-seq reads to the *A. tha* genome to validate whether there were reads that could not be aligned to the genome.

## Aligning reads to plant genomes

### Indexing

```bash
cd /mnt/e/project/srna/genome/plant/genome

bowtie-build --quiet --threads 12 Atha.fna Atha
```

- NOTICE

 > I used HPCC for such a number of files. So the bash script were 12 threads (my own computer), and I changed it into 24 threads when submit to  HPCC.
 >
 > Meanwhile, all the rsync step would be optional, depending on your choice.

```bash
mkdir -p /mnt/e/project/srna/output/bam/plant
mkdir -p /mnt/e/project/srna/output/fastq
cd /mnt/e/project/srna/trim
```

- Upload file to the HPCC

```bash
rsync -avP /mnt/e/project/srna/trim wangq@202.119.37.251:jyq/project/srna/bowtie2/
rsync -avP /mnt/e/project/srna/output wangq@202.119.37.251:jyq/project/srna/bowtie2/
rsync -avP /mnt/e/project/srna/genome wangq@202.119.37.251:jyq/project/srna/bowtie2/
rsync -avP /mnt/e/project/srna/annotation wangq@202.119.37.251:jyq/project/srna/bowtie2/
```

### Aligning

This step could provide us -N 0 (no mismatch in seed region, default: 22) reads aligned.
Use `--xeq` parameter. The reason why I used this is that CIGAR in `.sam` generated by bowtie2 could change M to =/X for more detailed information. Using the detailed CIGAR could help us getting the reads matched perfectly (without any mismatch). The assumption we use here is that reads match perfectly to plant genome could be regarding as arising from plant, and the same for bacteria.

We used this parameter for bowtie2 alignment `-N 1`.

```bash
parallel -j 3 " \
bowtie2 -q {}_trimmed.fq.gz -N 1 --xeq \
-x ../genome/plant/Atha/Atha --threads 4 \
-S ../output/bam/plant/{}_plantall1mis.sam \
" ::: $(ls SRR*.fq.gz | perl -p -e 's/_trimmed.+gz$//')
```

```bash
bsub -q mpi -n 24 -J pall1mis -o . "bash plantall1mis.sh"
```

### Convert sam to bam file for minimum storage stress

```bash
cd /mnt/e/project/srna/output/bam/plant

parallel -j 3 " 
samtools sort -@ 4 {1}.sam > {1}.sort.bam 
samtools index {1}.sort.bam 
" ::: $(ls *.sam | perl -p -e 's/\.sam$//')
```

### Reads ratio from plant

The sRNA-seq samples we gathered from NCBI were all completed in plant. So the original purpose was to detect the presence of sRNAs in plants. There were files orginated from two different parameters: -N 0 reads aligning mode and -N 1 reads aligning mode.

Files originated from the -N 1 parameter contained all reads that could align to the plant genome included all reads (even mismatches existed, details of -N 1 in bowtie2 could be seen in bowtie2 help information).

```bash
mkdir -p /mnt/e/project/srna/output/count
cd /mnt/e/project/srna/output/count
mkdir trna rrna mrna all
cd ..

bash ../../script/plant_reads.sh > plant_reads.csv

cat plant_reads.csv | perl -n -e 'chomp;
@a = split/,/,$_;
if($a[0] eq "name"){print "$_,num\n";}
else{if(not defined $name){$i = 1;
$name = $a[0];print"$_,$i\n";}
else{if($a[0] eq $name){print"$_,$i\n";}
else{$i++;$name=$a[0];print"$_,$i\n";}}}
' > plant_reads_all.csv
```

```bash
Rscript -e '
library(ggplot2)
library(readr)
args <- commandArgs(T)
ct <- read.csv(args[1])
p <- ggplot(ct, aes(x = num, y = count, 
fill = factor(group, levels = c("unknown","plant")))) +
geom_bar(stat = "identity", position = "fill") +
labs(x = "File numbers", y = "Ratio of reads source")
p <- p + scale_x_continuous(breaks = seq(0, 240, 10)) +
scale_fill_manual(name = "reads source",
labels = c("non-plant", "plant"),
values = c("gray75", "seagreen3")) +
theme(panel.background = element_blank(),
axis.text.x  = element_text(angle=45, vjust=0.5))
ggsave(p, file = "../figure/plant_reads_all.pdf", width = 9, height = 4)
' plant_reads_all.csv
```

- Filter by ratio of aligning to plant

From the above results, it is clear that some sRNA-seq files cannot align to plant in relatively high ratio. A cut-off of more than 50% reads that cannot aligned to plant was used to filter those low quality seq files.

```bash
cd /mnt/e/project/srna/output/count

cat plant_reads_all.csv | mlr --icsv --otsv cat | \
tsv-summarize -H --group-by name --sum count > plant_all.tmp.tsv

cat plant_reads_all.csv | mlr --icsv --otsv cat | \
tsv-filter -H --str-eq group:plant | \
tsv-join -H --filter-file plant_all.tmp.tsv \
--key-fields name --append-fields count_sum | \
tsv-select -H -f name,count,count_sum,num | sed '1d' | \
perl -n -e 'chomp;@a = split/\t/,$_; $ratio=$a[1]/$a[2]*100;
printf("%s\t%.2f\t%s\n","$a[0]","$ratio",$a[3]);' | sed '1iname\tratio\tnum' > plant_ratio.tsv

perl ../../script/ratio2count.pl -b 2 -r plant_ratio.tsv | \
sort -nk 1 | sed '1iratio\tcount' > ratio_count_2.tsv

perl ../../script/ratio2count.pl -b 3 -r plant_ratio.tsv | \
sort -nk 1 | sed '1iratio\tcount' > ratio_count_3.tsv

rm *.tmp.*
```

```bash
cat ratio_count_2.tsv | perl -n -e 'chomp;$i=0;if($_=~/^r/){
print "ratio\n";}else{$_ =~ /^(\d+)\s+(\d+)$/;
for($i = 0; $i < $2; $i++){
print "$1\n";}}
' > ratio_2.tsv

cat ratio_count_3.tsv | perl -n -e 'chomp;$i=0;if($_=~/^r/){
print "ratio\n";}else{$_ =~ /^(\d+)\s+(\d+)$/;
for($i = 0; $i < $2; $i++){
print "$1\n";}}
' > ratio_3.tsv
```

- Waiting for update: **Mclust for predicting plant ratio cut-off**

```R
library(readr)
library(mclust)

ratio <- read_tsv("ratio_3.tsv")
dens <- Mclust(ratio$ratio)
# dens <- densityMclust(ratio$ratio)
summary(dens$BIC)
summary(dens, parameters = TRUE)
br <- seq(min(ratio$ratio), max(ratio$ratio), length = 33)
plot(dens, what = "density", data = ratio$ratio, breaks = br)
x <- seq(1, 100, length = 33)
cdens <- predict(dens, br, what = "cdens")
cdens <- t(apply(cdens, 1, function(d) d*dens$parameters$pro))
matplot(x, cdens, type = "l", lwd = 1, add = TRUE, lty = 1:3, col = 1)

h1 <- hist(Thickness[Year == "1872"], breaks = br, plot = FALSE)
h1$density <- h1$density*prop.table(table(Year))[1]
h2 <- hist(Thickness[Year == "1873-74"], breaks = br, plot = FALSE)
h2$density <- h2$density*prop.table(table(Year))[2]
x <- seq(min(Thickness)-diff(range(Thickness))/10, max(Thickness)+diff(range(Thickness))/10, length = 200)
cdens <- predict(dens, x, what = "cdens")
cdens <- t(apply(cdens, 1, function(d) d*dens$parameters$pro))
col <- adjustcolor(mclust.options("classPlotColors")[1:2], alpha = 0.3)
plot(h1, xlab = "Thickness", freq = FALSE, main = "", border = FALSE, col = col[1], xlim = range(x), ylim = range(h1$density, h2$density, cdens))
plot(h2, add = TRUE, freq = FALSE, border = FALSE, col = col[2])
matplot(x, cdens, type = "l", lwd = 1, add = TRUE, lty = 1:3, col = 1)
box()
```

- Filter by the cut-off

Using the previous step, we found out that the 0.3 was the best cut-off for excluding low quality plant aligned files.

```bash
cd /mnt/e/project/srna/output/count

cat plant_ratio.tsv | tsv-filter -H --ge ratio:30 > plant_30.tsv

cat plant_reads_all.csv | mlr --icsv --otsv cat | \
tsv-join -H --filter-file plant_30.tsv --key-fields name | \
mlr --itsv --ocsv cat > plant_reads_30.csv
```

```bash
Rscript -e '
library(ggplot2)
library(readr)
args <- commandArgs(T)
ct <- read.csv(args[1])
p <- ggplot(ct, aes(x = num, y = count, 
fill = factor(group, levels = c("unknown","plant")))) +
geom_bar(stat = "identity", position = "fill") +
labs(x = "File numbers", y = "Ratio of reads source")
p <- p + scale_x_continuous(breaks = seq(0, 240, 10)) +
scale_fill_manual(name = "reads source",
labels = c("non-plant", "plant"),
values = c("gray75", "seagreen3")) +
theme(panel.background = element_blank(),
axis.text.x  = element_text(angle=45, vjust=0.5))
ggsave(p, file = "../figure/plant_reads_30.pdf", width = 9, height = 4)
' plant_reads_30.csv
```

### Plant sRNA reads distribution

*A. tha* annotation is relatively abundant with full information. Using `.gff` file, it is better using gene to calculate col 3 rather than using directly RNA annotation, such as tRNA *et. al.*. It almost the same using two different methods, though there will be a few lines of difference, *e.g.* miRNA will provide you 5p and 3p, but gene will just give you a region. Because of the existence of transcript splicing, extracting annotation of gene could directly give out the different RNA region to reach the goal of deciding region that reads originated.

- All 240 sRNA-seq files

```bash
cd /mnt/e/project/srna/annotation/plant/Atha

cat Atha.gff | grep -v '#' | tsv-filter --str-eq 3:gene --iregex 9:gene_biotype=tRNA > Atha_trna.gff
cat Atha.gff | grep -v '#' | tsv-filter --str-eq 3:gene --iregex 9:gene_biotype=rRNA > Atha_rrna.gff
cat Atha.gff | grep -v '#' | tsv-filter --str-eq 3:gene --iregex 9:gene_biotype=miRNA > Atha_mirna.gff
cat Atha.gff | grep -v '#' | tsv-filter --str-eq 3:gene --iregex 9:gene_biotype=snRNA > Atha_snrna.gff
cat Atha.gff | grep -v '#' | tsv-filter --str-eq 3:gene --iregex 9:gene_biotype=snoRNA > Atha_snorna.gff
cat Atha.gff | grep -v '#' | tsv-filter --str-eq 3:gene --iregex 9:gene_biotype=lncRNA > Atha_lncrna.gff
cat Atha.gff | grep -v '#' | tsv-filter --str-eq 3:gene --iregex 9:gene_biotype=ncRNA > Atha_ncrna.gff
cat Atha.gff | grep -v '#' | tsv-filter --str-eq 3:gene --not-iregex 9:gene_biotype=snoRNA \
--not-iregex 9:gene_biotype=snRNA \
--not-iregex 9:gene_biotype=miRNA \
--not-iregex 9:gene_biotype=rRNA \
--not-iregex 9:gene_biotype=tRNA \
--not-iregex 9:gene_biotype=lncRNA \
--not-iregex 9:gene_biotype=ncRNA \
> Atha_mrna.gff
```

```bash
parallel -j 4 " \
cat Atha_{}.gff | convert2bed --input=gff --output=bed > Atha_{}.bed \
" ::: $(ls *_*.gff | perl -p -e 's/^Atha_(.+)\.gff/$1/')
```

- Count reads from different plant region

Here we used `SRR*_plantall.sort.bam` because of we wanted to check the different sRNA ratio - whether they were all miRNA or not.

```bash
cd /mnt/e/project/srna/output/count
bash ../../script/plant_rna_ratio.sh | tee plant_rna_ratio_all.csv
```

- Filtered by cut-off

```bash
cat plant_rna_ratio_all.csv | mlr --icsv --otsv cat | \
tsv-join -H --filter-file plant_30.tsv --key-fields name | \
mlr --itsv --ocsv cat > plant_rna_ratio_30.tmp.csv

cat plant_rna_ratio_30.tmp.csv | perl -n -e 'chomp;
@a = split/,/,$_;
if($a[0] eq "name"){print "$_,num\n";}
else{if(not defined $name){$i = 1;
$name = $a[0];print"$_,$i\n";}
else{if($a[0] eq $name){print"$_,$i\n";}
else{$i++;$name=$a[0];print"$_,$i\n";}}}
' > plant_rna_ratio_30.csv

rm *.tmp.*
```

```bash
Rscript -e '
library(ggplot2)
library(readr)
args <- commandArgs(T)
plant <- read.csv(args[1])
p <- ggplot(plant, aes(x = num, y = count, 
fill = factor(group, levels = c("mrna","rrna","ncrna","lncrna","snrna","snorna","trna","mirna")))) +
geom_bar(stat = "identity", position = "fill") +
labs(x = "Seq files", y = "Ratio of reads from plant regions")
p <- p + scale_x_continuous(breaks = seq(0, 185, 5)) +
scale_fill_manual(name = "RNA region",
labels = c("mRNA","rRNA","ncRNA","lncRNA","snRNA","snoRNA","tRNA","miRNA"),
values = c("#70ACAB","#FFF18F","#DAC847","#E3842C","#70795E","#3C3F38","#3A571F","#0B1F25")) +
theme(panel.background = element_blank(),
axis.text.x  = element_text(angle=45, vjust=0.5))
ggsave(p, file = "/mnt/e/project/srna/output/figure/plant_rna_ratio_30.pdf", width = 9, height = 4)
' plant_rna_ratio_30.csv
```

### Summary of the plant alignment

- Give out the basic information among different groups.

```bash
cat plant_30.tsv | tsv-summarize -H --mean ratio --median ratio | mlr --itsv --omd cat
```

| ratio_mean    | ratio_median |
| ------------- | ------------ |
| 75.4014285714 | 82.1         |

## Aligning different reads to bacterial genomes

After aligned sRNA reads to the plant genome, we split all reads into two different parts, which was reads originally from plants and reads appeared out of nowhere. The goal was to explore where did those reads come from.

We selected bacterial genomes of 161 species from NCBI RefSeq database. From the previous step, we split reads to 3 types: plant reads (matched perfectly to plant genome), reads which target plant genome (not perfectly matched plant genome but could be aligned in bowtie2) and unaligned reads (did not match plant genome at all).

In the bowtie2, the `--xeq` parameter should be added (detailed reasons could be seen above [Aligning](#aligning)

### Extract different seq files

I split all reads aligned to plant into 3 groups. They were named as aliall, 1mis and unali.
aliall: reads that aligned to plant genome perfectly (without any mismatch, originated from *A. tha*)
1mis: reads that aligned to plant genome which allowed a mismatch occured in the seed region (k-mer expand, `-L 22`)
unali: reads that did not to plant genome (in sam files contained `-F 4`)

```bash
cd /mnt/e/project/srna/output/bam/plant
```

```bash
for file in `ls SRR*.bam | perl -p -e 's/_.+bam$//'`
do
samtools view -@ 10 -h ${file}_plantall1mis.sort.bam | \
perl -n -e 'chomp;if($_=~/^@/){print "$_\n";}else{@array = split/\t/, $_;
if($array[5] =~ /^((?!X).)*$/ && $array[1] != 4){print "$_\n";}else{next;}}
' | samtools fastq -@ 10 | gzip > ../../fastq/${file}_plantall.fq.gz;
done
```

```bash
for file in `ls SRR*.bam | perl -p -e 's/_.+bam$//'`
do
samtools view -@ 10 -h ${file}_plantall1mis.sort.bam | \
perl -n -e 'chomp;if($_=~/^@/){print "$_\n";}else{@array = split/\t/, $_;
if($array[1] != 4){if($array[5] =~ /X/){print "$_\n";}else{next;}}}
' | samtools fastq -@ 10 | gzip > ../../fastq/${file}_plant1mis.fq.gz;
done
```

```bash
for file in `ls SRR*.bam | perl -p -e 's/_.+bam$//'`
do
samtools view -h -@ 10 -f 4 ${file}_plantall1mis.sort.bam | \
samtools fastq -@ 10 | gzip > ../../fastq/${file}_plantunali.fq.gz;
done
```

### Indexing

Here we treated 161 bacterial genomes all as chromosome

```bash
cd /mnt/e/project/srna/genome/bacteria

bowtie2-build --threads 12 --quiet bacteria.fna bacteria
```

### Aligning

**Notice:** path should be adjusted appropriately by yourself depending on your device

```bash
mkdir -p /mnt/e/project/srna/output/bam/bacteria
cd /mnt/e/project/srna/output/fastq
```

- Aligning unaligned reads to bacteria species.

```bash
parallel -j 4 " \
bowtie2 -q {}_plantunali.fq.gz -N 0 --xeq \
-x ../../genome/bacteria/bacteria --threads 6 -S ../bam/bacteria/{}_unali.sam \
" ::: $(ls SRR*_plantunali.fq.gz | perl -p -e 's/_plant.+gz$//')
```

```bash
bsub -q mpi -n 24 -J unali -o . "bash unali.sh"
```

- Aligning 1 mismatch allowed reads to bacteria species.

```bash
parallel -j 4 " \
bowtie2 -q {}_plant1mis.fq.gz -N 0 --xeq \
-x ../../genome/bacteria/bacteria --threads 6 -S ../bam/bacteria/{}_1mis.sam \
" ::: $(ls SRR*_plant1mis.fq.gz | perl -p -e 's/_plant.+gz$//')
```

```bash
bsub -q mpi -n 24 -J 1mis -o . "bash 1mis.sh"
```

- Aligning perfectly matched reads to bacteria species.

```bash
parallel -j 4 " \
bowtie2 -q {}_plantaliall.fq.gz -N 0 --xeq \
-x ../../genome/bacteria/bacteria --threads 6 -S ../bam/bacteria/{}_aliall.sam \
" ::: $(ls SRR*_plantaliall.fq.gz | perl -p -e 's/_plant.+gz$//')
```

```bash
bsub -q mpi -n 24 -J all -o . "bash all.sh"
```

### Convert sam to bam file for minimum storage stress

```bash
cd /mnt/e/project/srna/output/bam/bacteria

parallel -j 3 " 
samtools sort -@ 4 {1}.sam > {1}.sort.bam 
samtools index {1}.sort.bam 
" ::: $(ls *.sam | perl -p -e 's/\.sam$//')
```

```bash
rm *.sam
# clear all sam, bam files could be read by samtools view
```

### Filter those aligned reads

The goal was to identify all the sRNA reads that belong to bacteria (which matched bacterial genome perfectly).

```bash
mkdir -p /mnt/e/project/srna/output/bam/bac_tsv
cd /mnt/e/project/srna/output/bam/bacteria

for file in `ls SRR*.bam | perl -p -e 's/\.sort\.bam$//'`
do
samtools view -@ 10 ${file}.sort.bam | \
tsv-filter --not-iregex 6:= --ne 2:4 > ../bac_tsv/${file}.tsv;
done
```

### Reads ratio from bacteria

All the sRNA reads aligned perfectly to bacterial genomes were regarded as the reads orginated from bacteria. Previously, the results were suggested that all sRNA-seq files of the plant had unknown reads for proximately 20%. Here we calculated the ratio of all reads from bacteria for each file.

- Ratio of reads aligned to bacteria / all non-plant reads

```bash
cd /mnt/e/project/srna/output/count
bash ../../script/bac_reads.sh | tee bac_reads.csv
```

```bash
cat bac_reads.csv | mlr --icsv --otsv cat | \
tsv-join -H --filter-file plant_30.tsv --key-fields name | \
mlr --itsv --ocsv cat > bac_reads_30.tmp.csv

cat bac_reads_30.tmp.csv | perl -n -e 'chomp;
@a = split/,/,$_;
if($a[0] eq "name"){print "$_,num\n";}
else{if(not defined $name){$i = 1;
$name = $a[0];print"$_,$i\n";}
else{if($a[0] eq $name){print"$_,$i\n";}
else{$i++;$name=$a[0];print"$_,$i\n";}}}
' > bac_reads_30.csv

rm *.tmp.*
```

```bash
Rscript -e '
library(ggplot2)
library(readr)
args <- commandArgs(T)
ct <- read.csv(args[1])
p <- ggplot(ct, aes(x = num, y = count, 
fill = factor(group, levels = c("unknown","bacteria","plant")))) +
geom_bar(stat = "identity", position = "fill") +
labs(x = "File numbers", y = "Ratio of reads source")
p <- p + scale_x_continuous(breaks = seq(0, 185, 5)) +
scale_fill_manual(name = "reads source",
labels = c("unknown", "bacteria", "plant"),
values = c("gray75", "tan3", "seagreen3")) +
theme(panel.background = element_blank(),
axis.text.x  = element_text(angle=45, vjust=0.5))
ggsave(p, file = "../figure/bac_reads_30.pdf", width = 9, height = 4)
' bac_reads_30.csv
```

### Summary of the plant alignment

Count reads from different species (plant or bacteria)

```bash
cat bac_reads_30.csv | mlr --icsv --otsv cat | \
tsv-summarize -H --group-by name --sum count > bac_30.tmp.tsv

cat bac_reads_30.csv | mlr --icsv --otsv cat | \
tsv-join -H --filter-file bac_30.tmp.tsv \
--key-fields name --append-fields count_sum | \
tsv-select -H -f name,count,count_sum,group | sed '1d' | \
perl -n -e 'chomp;@a = split/\t/,$_; $ratio=$a[1]/$a[2]*100;
printf("%s\t%.2f\t%s\n","$a[0]","$ratio",$a[3]);' | sed '1iname\tratio\tgroup' > bac_ratio_30.tsv

rm *.tmp.*
```

```bash
cat bac_ratio_30.tsv | tsv-summarize -H --group-by group --mean ratio --median ratio | mlr --itsv --omd cat
```

| group    | ratio_mean     | ratio_median |
| -------- | -------------- | ------------ |
| plant    | 75.4014285714  | 82.1         |
| bacteria | 0.897586206897 | 0.15         |
| unknown  | 23.7014778325  | 17.87        |
